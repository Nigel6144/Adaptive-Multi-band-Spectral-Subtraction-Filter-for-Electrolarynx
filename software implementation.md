# Electrolarynx Speech Enhancement

A MATLAB implementation of an electrolarynx speech enhancement filter using **minimum-statistics** adaptive noise estimation together with **multi-band spectral subtraction**. The script reduces device-induced buzzing and background noise while preserving important speech characteristics by applying different subtraction factors across frequency bands.

---

## Files

- `electrolarynx_filter.m` — Main MATLAB script .
- `electrolarynx_noisy_audio.wav` — Example noisy recording (place your input here).
- `electrolarynx_enhanced.wav` — Output generated by the script.
- `README.md` — This file.
- Note: rename your script file to `electrolarynx_filter.m` or modify usage instructions accordingly.


## Folder Access
- TO ACCESS THE FOLDER CLICK ON THIS LINK:
  https://drive.google.com/drive/folders/1ZBnOQJu7pwbS7r5lpNrQUE1H33QCisqD?usp=sharing


---

## Quick description

The algorithm performs the following steps:
1. Read the noisy electrolarynx audio file and compute the STFT.
2. Estimate the noise in each frequency bin using **minimum-statistics** tracking.
3. Perform **multi-band spectral subtraction**: partition the spectrum into frequency bands and apply band-specific over-subtraction factors to remove noise while retaining speech cues.
4. Reconstruct the enhanced signal using the original phase and inverse STFT, normalize and save the result.

---

## Requirements

- MATLAB (R2018a or newer recommended).
- Signal Processing Toolbox (for `stft` / `istft` functions on some MATLAB versions).

## How to run

1. Place your noisy WAV file in the working directory and name it `electrolarynx_noisy_audio.wav` (or change the filename in the script).
2. Open MATLAB and run the script :
   For example

```matlab
electrolarynx_filter.m
```

3. The script writes the enhanced waveform to `electrolarynx_enhanced.wav` and plays it back.

---

## Important parameters (in-script)

- `frame_len` — STFT frame length in samples (default `64`). Smaller frames reduce latency but may reduce spectral resolution.
- `overlap` — Overlap length between frames (default 32). Typical values are 50% of `frame_len`.
- `nfft` — FFT length (default `512`). Choose >= `frame_len` for good spectral resolution.
- `lambda_D` — Smoothing factor for noise tracking (default `0.85`). Higher values give slower adaptation while lower values introduce a musical artifact effect.
- `min_win` — Minimum-statistics window length (frames) used to find local minima for noise (default `15`). Larger windows produce more conservative noise estimates.
- `freq_bands` — Frequency band edges in Hz. Default in the script: `[0, 300, 1000, 2000, 3000, 5000, fs/2]`.
- `alpha_factors` — Over-subtraction factor for each band (vector). Larger values remove more noise but may increase speech distortion. The default example uses `[1, 1.3, 1.6, 100, 100]` — **these extreme values may be placeholders**; tune them for your recordings.

---

## How it works (brief)
- The code performs STFT on a predefined frame length and estimates the noise spectrum by choosing the minimum value of each frequency for the first 15 samples of audio.
- Subsequently, the noise spectrum is updated using minimum statistics with a provision to adjust updation factor Lambda according to your requirement.
- The noise spectrum is subtracted from the noisy audio with a pre-defined subtraction factor(alpha) for each frequency band to prevent speech distortion.
- The audio signal is reconstructed with its initial phase and accounting for the 50% overlap introduced previously using the ifft function.

This combination aims to suppress the electrolarynx buzzing while preserving intelligibility and naturalness.

---

## Evaluation

You can evaluate enhancement performance using objective metrics such as:

- **DNSMOS** (Deep Noise Supression Mean Opinion Score)
- **PESQ** (Perceptual Evaluation of Speech Quality)
- **STOI** (Short-Time Objective Intelligibility)
- SNR improvement (simple energy-based SNR before/after)

Community implementations for PESQ/STOI exist in Python and MATLAB — add reference clean/noisy files and run evaluation scripts to generate numbers and plots. Save results to a `results/` folder and include example audio for subjective listening tests.

---

## Tuning tips

- Start with conservative alpha values (close to 1) and vary only for bands where the buzzing persists.
- Tune `min_win` and `lambda_D` to match the dynamics of your recording: longer `min_win` for slowly varying buzz, smaller for quick changes.
- Visualize spectrograms of noisy vs enhanced audio to inspect which bands still contain device noise.
- If musical/tonal buzzing remains, adjust the lambda values.

---

## Real-time & embedded considerations

- Current implementation is offline (batch). For real-time use on embedded platforms (ESP32, Zynq, etc.):
  - Use frame buffering with overlap-add and an efficient fixed-point FFT.
  - Reduce `nfft` and `frame_len` to meet latency constraints.
  - Pre-compute band index maps and avoid dynamic memory allocations inside the audio callback.

---

## Caveats & known issues

- Over-aggressive subtraction causes musical noise artifacts or speech distortion. Carefully balance `alpha_factors` for perceptual quality.
- Phase is preserved from the noisy signal; advanced phase reconstruction methods (e.g., iterative Griffin–Lim variants) may further improve naturalness but add complexity.


---

## Contact / Acknowledgements

If you found this helpful or want to collaborate, open an issue or PR — or contact the repository owner.



