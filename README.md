# Electrolarynx Speech Enhancement

A MATLAB implementation of an electrolarynx speech enhancement filter using **minimum-statistics** adaptive noise estimation together with **multi-band spectral subtraction**. The script reduces device-induced buzzing and background noise while preserving important speech characteristics by applying different subtraction factors across frequency bands.

---

## Files

- `enhance_el.m` — Main MATLAB script (the code you provided).
- `electrolarynx_noisy_audio.wav` — Example noisy recording (place your input here).
- `electrolarynx_enhanced_2.wav` — Output generated by the script.
- `README.md` — This file.

> Note: rename your script file to `enhance_el.m` or modify usage instructions accordingly.

---

## Quick description

The algorithm performs the following steps:
1. Read the noisy electrolarynx audio file and compute the STFT.
2. Estimate the noise in each frequency bin using **minimum-statistics** tracking.
3. Perform **multi-band spectral subtraction**: partition the spectrum into frequency bands and apply band-specific over-subtraction factors to remove noise while retaining speech cues.
4. Reconstruct the enhanced signal using the original phase and inverse STFT, normalize and save the result.

---

## Requirements

- MATLAB (R2018a or newer recommended).
- Signal Processing Toolbox (for `stft` / `istft` functions on some MATLAB versions).

If your MATLAB version does not expose `stft`/`istft`, you can substitute equivalent STFT/ISTFT functions (community implementations or custom code).

---

## How to run

1. Place your noisy WAV file in the working directory and name it `electrolarynx_noisy_audio.wav` (or change the filename in the script).
2. Open MATLAB and run the script (for example):

```matlab
run enhance_el.m
```

3. The script writes the enhanced waveform to `electrolarynx_enhanced_2.wav` and (optionally) plays it back.

---

## Important parameters (in-script)

- `frame_len` — STFT frame length in samples (default `64`). Smaller frames reduce latency but may reduce spectral resolution.
- `overlap` — Overlap length between frames (default `32`). Typical values are 50% of `frame_len`.
- `nfft` — FFT length (default `512`). Choose >= `frame_len` for good spectral resolution.
- `lambda_D` — Smoothing factor for noise tracking (default `0.85`). Higher values give slower adaptation.
- `min_win` — Minimum-statistics window length (frames) used to find local minima for noise (default `15`). Larger windows produce more conservative noise estimates.
- `freq_bands` — Frequency band edges in Hz. Default in the script: `[0, 300, 1000, 2000, 3000, 5000, fs/2]`.
- `alpha_factors` — Over-subtraction factor for each band (vector). Larger values remove more noise but may increase speech distortion. The default example uses `[1, 1.3, 1.6, 100, 100]` — **these extreme values may be placeholders**; tune them for your recordings.

---

## How it works (brief)

- **Minimum-statistics noise estimation**: Instead of assuming stationary noise, the algorithm tracks the minimum spectral magnitude within a sliding window. The minimum statistics approach is robust for estimating slowly varying noise floors such as the electrolarynx buzz.

- **Multi-band spectral subtraction**: The full spectrum is split into perceptually motivated bands. Each band uses a different subtraction factor `\alpha` so that low-frequency bands (carrying voicing and formant information) are treated carefully while higher-frequency regions (often dominated by device hum and broadband noise) can be aggressively reduced.

This combination aims to suppress the electrolarynx buzzing while preserving intelligibility and naturalness.

---

## Evaluation

You can evaluate enhancement performance using objective metrics such as:

- **PESQ** (Perceptual Evaluation of Speech Quality)
- **STOI** (Short-Time Objective Intelligibility)
- SNR improvement (simple energy-based SNR before/after)

Community implementations for PESQ/STOI exist in Python and MATLAB — add reference clean/noisy files and run evaluation scripts to generate numbers and plots. Save results to a `results/` folder and include example audio for subjective listening tests.

---

## Tuning tips

- Start with conservative alpha values (close to 1) and increase only for bands where the buzzing persists.
- Tune `min_win` and `lambda_D` to match the dynamics of your recording: longer `min_win` for slowly varying buzz, smaller for quick changes.
- Visualize spectrograms of noisy vs enhanced audio to inspect which bands still contain device noise.
- If musical/tonal buzzing remains, experiment with harmonic suppression or notch filtering around the electrolarynx fundamental frequency.

---

## Real-time & embedded considerations

- Current implementation is offline (batch). For real-time use on embedded platforms (ESP32, Zynq, etc.):
  - Use frame buffering with overlap-add and an efficient fixed-point FFT.
  - Reduce `nfft` and `frame_len` to meet latency constraints.
  - Pre-compute band index maps and avoid dynamic memory allocations inside the audio callback.

---

## Caveats & known issues

- Over-aggressive subtraction causes musical noise artifacts or speech distortion. Carefully balance `alpha_factors` for perceptual quality.
- Phase is preserved from the noisy signal; advanced phase reconstruction methods (e.g., iterative Griffin–Lim variants) may further improve naturalness but add complexity.


---

## Contact / Acknowledgements

If you found this helpful or want to collaborate, open an issue or PR — or contact the repository owner.



